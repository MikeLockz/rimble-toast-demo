{"version":3,"sources":["components/ConnectButton.js","components/SmartContractCard.js","components/RimbleWeb3.js","components/InstructionsCard.js","App.js","components/TransactionStatusCard.js","serviceWorker.js","index.js"],"names":["ConnectButton","react_default","a","createElement","index_es","size","mr","onClick","this","props","initAccount","disabled","account","React","Component","contractAbi","constant","inputs","name","outputs","payable","stateMutability","type","SmartContractCard","state","value","getNumber","_ref","Object","esm_extends","contract","_this","methods","getCounter","call","then","Number","toString","setState","catch","error","console","log","resetCounter","contractMethodSendWrapper","incrementCounter","decrementCounter","_this2","initContract","width","mx","px","h1","fontSize","textAlign","mb","py","pt","borderTop","borderColor","justifyContent","components_ConnectButton","RimbleTransactionContext","createContext","web3","initWeb3","RimbleTransaction","_callee","regenerator_default","wrap","_context","prev","next","window","ethereum","Web3","currentProvider","toastProvider","addMessage","message","variant","stop","_callee2","address","abi","_context2","eth","Contract","sent","t0","_callee3","_context3","enable","wallets","contractMethod","transaction","created","Date","now","status","showTransactionToast","_this$state","send","from","on","hash","confirmationNumber","receipt","objectSpread","incomingTransaction","lastUpdated","toastMeta","getTransactionToastMeta","transactionToastMeta","transactionHash","actionHref","actionText","icon","Provider","assign","Consumer","InstructionsCard","App","className","my","RimbleWeb3","components_SmartContractCard","ref","node","components_InstructionsCard","Boolean","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c596b025.chunk.js","sourcesContent":["import React from \"react\";\nimport { Button } from \"rimble-ui\";\n\nclass ConnectButton extends React.Component {\n  render() {\n    return (\n      <Button\n        size={\"medium\"}\n        mr={4}\n        onClick={this.props.initAccount}\n        disabled={this.props.account}\n      >\n        Connect\n      </Button>\n    );\n  }\n}\n\nexport default ConnectButton;\n","import React from \"react\";\nimport { Card, Heading, Box, Text, Flex, OutlineButton } from \"rimble-ui\";\nimport ConnectButton from \"./ConnectButton\";\n\n// Address of the deployed smart contract (from etherscan)\nconst contractAddress = \"0x0f69f0ac4b92bf0d101b5747eed3fa6b653a36f8\";\n\n// Copied from remix ide\nconst contractAbi = [\n  {\n    constant: false,\n    inputs: [],\n    name: \"decrementCounter\",\n    outputs: [],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    constant: false,\n    inputs: [],\n    name: \"incrementCounter\",\n    outputs: [],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    constant: false,\n    inputs: [],\n    name: \"reset\",\n    outputs: [],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"constructor\"\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: \"getCounter\",\n    outputs: [\n      {\n        name: \"\",\n        type: \"int256\"\n      }\n    ],\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n];\n\nclass SmartContractCard extends React.Component {\n  state = {\n    value: 0\n  };\n\n  // gets the number stored in smart contract storage\n  getNumber = ({ ...props }) => {\n    const { contract } = this.props;\n    try {\n      contract.methods\n        .getCounter()\n        .call()\n        .then(value => {\n          value = Number(value.toString());\n          this.setState({ value });\n        })\n        .catch(error => {\n          // TODO: pass error back up to RimbleTransaction component?\n          console.log(error);\n          this.setState({ error });\n        });\n    } catch (error) {\n      // TODO: pass error back up to RimbleTransaction component?\n      console.log(\"error\", error);\n    }\n    console.log(\"got number\", this.state.value);\n  };\n\n  resetCounter = () => {\n    this.props.contractMethodSendWrapper(\"reset\");\n  };\n  incrementCounter = () => {\n    this.props.contractMethodSendWrapper(\"incrementCounter\");\n  };\n  decrementCounter = () => {\n    this.props.contractMethodSendWrapper(\"decrementCounter\");\n  };\n\n  // TODO: how to get the lifecycle methods of a transaction to be accessible here?\n\n  // TODO: onTransactionReceipt\n\n  componentDidMount() {\n    // Init the contract after the web3 provider has been determined\n    this.props.initContract(contractAddress, contractAbi).then(() => {\n      // Can finally interact with contract\n      this.getNumber();\n    });\n  }\n\n  render() {\n    return (\n      <Card width={\"600px\"} mx={\"auto\"} px={4}>\n        <Heading.h1 fontSize={5} textAlign={\"center\"} px={4} mb={5}>\n          Rimble Smart Contract Example\n        </Heading.h1>\n        <Box>\n          <Box py={4}>\n            <Text mb={2} fontSize={3}>\n              Value from smart contract:\n            </Text>\n            <Text fontSize={6} textAlign={\"center\"}>\n              {this.state.value}\n            </Text>\n          </Box>\n\n          <Flex\n            px={0}\n            pt={4}\n            borderTop={1}\n            borderColor={\"#E8E8E8\"}\n            justifyContent=\"space-between\"\n          >\n            <ConnectButton\n              initAccount={this.props.initAccount}\n              account={this.props.account}\n            />\n\n            <OutlineButton\n              size={\"medium\"}\n              mr={4}\n              onClick={this.resetCounter}\n              disabled={!this.props.account}\n            >\n              Reset\n            </OutlineButton>\n\n            <OutlineButton\n              size={\"medium\"}\n              mr={4}\n              onClick={this.incrementCounter}\n              disabled={!this.props.account}\n            >\n              Increment\n            </OutlineButton>\n\n            <OutlineButton\n              size={\"medium\"}\n              onClick={this.decrementCounter}\n              disabled={!this.props.account}\n            >\n              Decrement\n            </OutlineButton>\n          </Flex>\n        </Box>\n      </Card>\n    );\n  }\n}\n\nexport default SmartContractCard;\n","import React from \"react\";\nimport Web3 from \"web3\"; // uses latest 1.x.x version\n\nconst RimbleTransactionContext = React.createContext({\n  contract: {},\n  account: {},\n  web3: {},\n  initWeb3: () => {},\n  initContract: () => {},\n  initAccount: () => {}\n});\n\nclass RimbleTransaction extends React.Component {\n  static Consumer = RimbleTransactionContext.Consumer;\n\n  // Initialize a web3 provider\n  initWeb3 = async () => {\n    let web3 = {};\n\n    // Check for modern web3 provider\n    if (window.ethereum) {\n      console.log(\"Using modern web3 provider.\");\n      web3 = new Web3(window.ethereum);\n    }\n    // Legacy dapp browsers, public wallet address always exposed\n    else if (window.web3) {\n      console.log(\"Legacy web3 provider. Try updating.\");\n      web3 = new Web3(window.web3.currentProvider);\n    }\n    // Non-dapp browsers...\n    else {\n      console.log(\n        \"Non-Ethereum browser detected. You should consider trying MetaMask!\"\n      );\n      window.toastProvider.addMessage(\"Something?\", {\n        message: \"No wallet available. Unable to continue.\",\n        variant: \"failure\"\n      });\n      web3 = false;\n    }\n\n    this.setState({ web3 });\n  };\n\n  initContract = async (address, abi) => {\n    console.log(\"creating contract\");\n    // Create contract on initialized web3 provider with given abi and address\n    try {\n      const contract = await new this.state.web3.eth.Contract(abi, address);\n      this.setState({ contract });\n    } catch (error) {\n      console.log(\"Could not create contract.\");\n      window.toastProvider.addMessage(\"Something?\", {\n        message: \"Contract creation failed.\",\n        variant: \"failure\"\n      });\n    }\n  };\n\n  initAccount = async () => {\n    try {\n      // Request account access if needed\n      await window.ethereum.enable().then(wallets => {\n        // TODO: should you always grab first address? What use cases would not be first address?\n        const account = wallets[0];\n        this.setState({ account });\n        console.log(\"wallet address:\", this.state.account);\n      });\n    } catch (error) {\n      // User denied account access...\n      console.log(\"error:\", error);\n      window.toastProvider.addMessage(\"Something?\", {\n        message: \"User needs to CONNECT wallet\",\n        variant: \"failure\"\n      });\n    }\n  };\n\n  contractMethodSendWrapper = contractMethod => {\n    let transaction = {};\n    transaction.created = Date.now();\n\n    // Show toast for starting transaction\n    console.log(\"Starting Transaction\");\n    transaction.status = \"started\";\n    this.showTransactionToast(transaction);\n\n    const { contract, account } = this.state;\n\n    try {\n      contract.methods[contractMethod]()\n        .send({ from: account })\n        .on(\"transactionHash\", hash => {\n          // Submitted to block and received transaction hash\n          console.log(\n            \"Transaction sent to block successfully. Result pending.\"\n          );\n          transaction.status = \"pending\";\n          this.showTransactionToast(transaction);\n        })\n        .on(\"confirmation\", (confirmationNumber, receipt) => {\n          const confidenceThreshold = 3;\n          // Somehow determine if this is an already confirmed tx? 10?\n          if (confirmationNumber < confidenceThreshold) {\n            console.log(\n              \"Confirmation \" +\n                confirmationNumber +\n                \". Threshold for confidence not met.\"\n            );\n            return;\n          } else if (confirmationNumber > confidenceThreshold) {\n            // TODO: Can you stop listening to these events?\n\n            console.log(\n              \"Confirmation \" +\n                confirmationNumber +\n                \". Confidence threshold already met.\"\n            );\n            return;\n          }\n\n          console.log(\"receipt: \", receipt);\n\n          // Update transaction with receipt details\n          transaction = { ...transaction, ...receipt };\n\n          // Confirmed with receipt\n          console.log(\"Transaction confirmed.\");\n          transaction.status = \"confirmed\";\n\n          this.showTransactionToast(transaction);\n\n          // check the status from result\n          if (receipt.status === true) {\n            console.log(\"Transaction completed successfully!\");\n            transaction.status = \"success\";\n          } else if (receipt.status === false) {\n            console.log(\"Transaction reverted due to error.\");\n            transaction.status = \"error\";\n          }\n\n          this.showTransactionToast(transaction);\n        })\n        .on(\"receipt\", receipt => {\n          // Received receipt\n          console.log(\"receipt: \", receipt);\n          // TODO: What properties of a receipt should be checked and show a toast?\n        })\n        .on(\"error\", error => {\n          // Errored out\n          console.log(error);\n          transaction.status = \"error\";\n          this.showTransactionToast(transaction);\n        });\n    } catch (error) {\n      console.log(\"Error calling method on smart contract.\");\n      transaction.status = \"error\";\n      this.showTransactionToast(transaction);\n    }\n  };\n\n  showTransactionToast = incomingTransaction => {\n    let transaction = {};\n    // Add extra info to transaction\n    transaction.lastUpdated = Date.now();\n    transaction = { ...transaction, ...incomingTransaction };\n\n    // Get text info for toast\n    let toastMeta = this.getTransactionToastMeta(transaction);\n\n    // Show toast\n    window.toastProvider.addMessage(\"...\", toastMeta);\n  };\n\n  getTransactionToastMeta = transaction => {\n    let transactionToastMeta = {};\n    let status = transaction.status;\n    let transactionHash = transaction.transactionHash;\n\n    // TODO: Move this into external file and import\n    switch (status) {\n      case \"started\":\n        transactionToastMeta = {\n          message: \"Started a new transaction\",\n          actionHref: \"\",\n          actionText: \"\",\n          variant: \"default\",\n          icon: \"InfoOutline\"\n        };\n        break;\n      case \"pending\":\n        transactionToastMeta = {\n          message: \"Transaction is pending\",\n          actionHref: \"\",\n          actionText: \"\",\n          variant: \"processing\"\n        };\n        break;\n      case \"confirmed\":\n        transactionToastMeta = {\n          message: \"Transaction is confirmed\",\n          actionHref: \"https://rinkeby.etherscan.io/tx/\" + transactionHash,\n          actionText: \"View on Etherscan\",\n          variant: \"success\"\n        };\n        break;\n      case \"success\":\n        transactionToastMeta = {\n          message: \"Transaction completed successfully\",\n          actionHref: \"https://rinkeby.etherscan.io/tx/\" + transactionHash,\n          actionText: \"View on Etherscan\",\n          variant: \"success\"\n        };\n        break;\n      case \"error\":\n        transactionToastMeta = {\n          message: \"Error\",\n          actionHref: \"https://rinkeby.etherscan.io/tx/\" + transactionHash,\n          actionText: \"View on Etherscan\",\n          variant: \"failure\"\n        };\n        break;\n      default:\n        break;\n    }\n    return transactionToastMeta;\n  };\n\n  state = {\n    contract: {},\n    account: null,\n    web3: null,\n    initWeb3: this.initWeb3,\n    initContract: this.initContract,\n    initAccount: this.initAccount,\n    contractMethodSendWrapper: this.contractMethodSendWrapper\n  };\n\n  componentDidMount() {\n    this.initWeb3();\n  }\n\n  render() {\n    return (\n      <RimbleTransactionContext.Provider value={this.state} {...this.props} />\n    );\n  }\n}\n\nexport default RimbleTransaction;\n","import React from \"react\";\nimport { Card, Box } from \"rimble-ui\";\n\nclass InstructionsCard extends React.Component {\n  render() {\n    return (\n      <Card width={\"600px\"} mx={\"auto\"} px={4}>\n        <Box>\n          <p>Instructions:</p>\n          <ul>\n            <li>Make sure MetaMask is working in your browser</li>\n            <li>Set the network to Rinkeby Test Network</li>\n            <li>You'll need a little bit of eth for gas fees</li>\n          </ul>\n\n          <p>About</p>\n          <p>\n            This is an example of a webapp that interacts with a Smart Contract.\n            The demo uses Web3.js and Rimble UI Components to show the status of\n            a Smart Contract transaction via toast messages.{\" \"}\n          </p>\n        </Box>\n      </Card>\n    );\n  }\n}\n\nexport default InstructionsCard;\n","import React, { Component } from \"react\";\nimport { Box, ToastMessage } from \"rimble-ui\";\nimport SmartContractCard from \"./components/SmartContractCard\";\nimport RimbleWeb3 from \"./components/RimbleWeb3\";\nimport InstructionsCard from \"./components/InstructionsCard\";\nimport TransactionStatusCard from \"./components/TransactionStatusCard\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Box my={\"auto\"}>\n          <RimbleWeb3>\n            <RimbleWeb3.Consumer>\n              {({\n                web3,\n                contract,\n                account,\n                initContract,\n                initAccount,\n                contractMethodSendWrapper\n              }) => (\n                <div>\n                  {/* Conditionally render child comonents dependent on web3 being loaded */}\n                  {web3 ? (\n                    <div>\n                      <SmartContractCard\n                        contract={contract}\n                        account={account}\n                        initContract={initContract}\n                        initAccount={initAccount}\n                        contractMethodSendWrapper={contractMethodSendWrapper}\n                      />\n                      {/* FUTURE: We need to make sure multiple components can consume a transaction's status */}\n                      {/* <TransactionStatusCard /> */}\n                    </div>\n                  ) : null}\n                </div>\n              )}\n            </RimbleWeb3.Consumer>\n          </RimbleWeb3>\n          <ToastMessage.Provider ref={node => (window.toastProvider = node)} />\n        </Box>\n\n        <InstructionsCard />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from \"react\";\nimport { Card, Pill, Flex } from \"rimble-ui\";\n\nclass TransactionStatusCard extends React.Component {\n  render() {\n    return (\n      <Card>\n        <Flex\n          px={0}\n          pt={4}\n          borderTop={1}\n          borderColor={\"#E8E8E8\"}\n          justifyContent=\"space-between\"\n        >\n          <div>\n            Transaction Status: <Pill color={\"gray\"}>unknown</Pill>\n          </div>\n        </Flex>\n      </Card>\n    );\n  }\n}\n\nexport default TransactionStatusCard;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}